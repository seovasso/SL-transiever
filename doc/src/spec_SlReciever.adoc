= Спецификация модуля приемника SL-канала :SlReciever
//===========
// Compile:
// evgeniy@N7-63:~/Documents/2015VV024/doc$ asciidoctor-pdf -a pdf-style=/home/evgeniy/Documents/RISC-V/fizika-theme.yml -a pdf-fontsdir=/home/evgeniy/Downloads/fonts/Combo/ ./src/2015VV024_datasheet.adoc && mv ./src/2015VV024_datasheet.pdf ./ && evince ./2015VV024_datasheet.pdf
:Authors: Василий Мочалов
:Email:   seovasso@gmail.com
:Date:      13.10.2017
:Revision:  0.3
:toc:       right
:toclevels: 3
:source-highlighter: rouge
:table-caption:     Таблица
:listing-caption:   Код
:chapter-label:     Глава
:toc-title:         Оглавление
:version-label:     Версия
:figure-caption:    Рисунок
:imagesdir:         ./../img/
:sectnums:
:sectnumlevels: 3
:revnumber: 1.1
:revdate:   15.12.2017
:revremark: Рабочая версия
[[rec-main-description]]
== Описание
Данный проект подразумевает реализацию RTL-описания на языке Verilog одноканального приемника SL-канала. Приемник принимает SL-сообщения. Сообщения могут содержать информацию четной разрядности от 8 до 32 разрядов. Разряд четности проверяется автоматически. Приемник способен принимать сообщения с частотой импульсов от 500кГц до 2МГц (при частоте тактового сигнала = 16МГц).

[[rec-top-level-description]]
== Описание верхнего уровня
.Порты цифрового модуля SlReciever
[cols="3*^1,1*^2,1*<3", halign="left", width=99%]
|===
|Название      |Тип   |Разрядность |Значение после сброса |Описание
|_rst_n_       |In    |1           | -                    |Асинхронный общий сигнал сброса
|_clk_         |In    |1           | -                    |Сигнал тактовой частоты
|_addr_        |In    |1           | -                    |Сигнал выбора регистра
|_wr_en_       |In    |1           | -                    |Сигнал разрешения записи
|_SL0_         |In    |1           |b1                    |Сигнал нулей SL канала
|_D_in_        |In    |32          | -                    |Данные для записи в регистры
|_SL1_         |in    |1           |b1                    |Сигнал единиц SL канала
|_irq_         |Out   |1           |b0                    |Сигнал запроса на прерывание
|_D_out_       |Out   |32          |h0000_0000            |Данные для чтения регистров
|===

<<<

[[rec-programm-model]]
== Программная модель
Пользователю для работы доступно два регистра:

* Служебный (*config_status_r*)
* Данных к отправке (*buffered_data_r*)

=== Служебный регистр

Служебный регистр состоит из двух частей - конфигурации и состояния. Части отвечающей за конфигурацию соответствуют младшие 16 разрядов, части состояния старшие.

[[rec_conf_table]]
.Назначение разрядов конфигурационной части служебного регистра (*config_status_r [15:0]*)
[cols="15*^", width=99%]
|===
|Bit        |15-13  |  12 |11 |10 |9  |8   |7       |6 |5 |4 |3 |2 |1 |0
|Name       |-    5+|*IRQM[4:0]*           |*PCE* 6+|*BC[5:0]*        |*SR*
|Mode       |R    5+|R/W                   |R/W   6+|R/W              |R/W
|Initial    |0      |0    |0  |0  |0  |0   |0       |0 |0 |1 |0 |0 |0 |0
|===

.Описание разрядов регистра конфигурационной части служебного регистра (*config_status_r [15:0]*)
. *SR* (soft reset) -- включает (*SR* = 0) и выключает (*SR* = 1) приемник
. *BC* (bit count) -- количество разрядов данных в отправляемом сообщении
. *IRQM* (interrupt request mask) -- маска разрядов причин прерываний.
  Задает, какие именно разряды причин прерываний вызывают запрос на прерывание. Описание разрядов причин прерываний можно посмотреть в <<rec_IRQM_table,таблице назначения разрядов части состояния служебного регистра>>. Соответствие разрядов поля IRQM и разрядов причин прерываний можно посмотреть в соответствующей <<rec_IRQM_table, таблице>>
. *PCE* (parity check enable) -- включение (*PCE* = 1) или выключение(*PCE* = 0) контроля четности

.Назначение разрядов части состояния служебного регистра (*config_status_r [31:16]*)
[cols="11*^", width=99%]
|===
|Bit     |31-30  |29       |28       |27       |26       |25       |24      |23-18 |17    |16
|Name    |-      |-        |*IRQICC* |*IRQLE*  |*IRQWLC* |*IRQPEM* |*IRQRM* |-     |*PEF* |*WRP*
|Mode    |R      |R        |R/W0     |R/W0     |R/W0     |R/W0     |R/W0    |R     |R     |R
|Initial |0      |0        |0        |0        |0        |0        |0       |0     |0     |0
|===

.Описание разрядов части состояния служебного регистра (*config_status_r [31:16]*)
. *WRP* - (word receiving process) -- разряд идущего процесса приема слова по SL-каналу.
. *PEF* - (parity error flag) -- разряд наличия ошибки четности в хранящемся в буфере сообщении.
. *IRQRM* - (interrupt request of recieved message) -- разряд запроса на прерывание успешно принятого сообщения.
. *IRQPEM* - (interrupt request of parity error message) -- разряд запроса на прерывание принятия слова не прошедшего проверку четности.
. *IRQWLC* - (interrupt request of word length check) --  разряд запроса на прерывание принятия слова неверной длинны.
. *IRQLE* - (interrupt request of level error on line) -- разряд запроса на прерывание ошибки уровня напряжения на линии SL-канала.
. *IRQICC* (interrupt request of incorrect  configuration change ) -- разряд запроса на прерывание попытки установить некорректную конфигурацию.

Разряды *IRQRM*, *IRQPEM*, *IRQWL*, *IRQLE*, *IRQWCC* и *IRQICC* отражают зарегистрированные приемником события. Более подробно события описаны разделе Работа с программной моделью -> <<rec_irq_events, Работа с прерываниями>>.

[[rec_IRQM_table]]
.Соответствие разрядов <<rec_conf_table,*IRQM [4:0]*>> и маскирования разрядов причин прерываний
[cols="2*^", width=99%]
|===
|Разряд поля *IRQM*       |Маскируемый разряд
|*IRQM0*                  |*IRQRM*
|*IRQM1*                  |*IRQPEM*
|*IRQM2*                  |*IRQWLC*
|*IRQM3*                  |*IRQLE*
|*IRQM4*                  |*IRQICC*
|===

=== Регистр полученных данных

.Назначение разрядов регистра полученных данных (*buffered_data_r*)
[cols="2*^", width=99%]
|===
|Bit     |31 - 0
|Name    |*DATA*
|Mode    |R
|Initial |0
|===
.Описание разрядов регистра полученных данных (*buffered_data_r*)
*DATA* - полученные данные

== Работа с программной моделью

=== Запись и чтение регистров
Управление модулем осуществляется путем записи или чтения регистров.

Для считывания текущего значения одного из регистров блока необходимо подать на порт _addr_ адрес регистра, указанный в <<rec_addr_table, таблице>>, длительностью не меньше такта опорной тактовой частоты _clk_. Значение регистра будет сформировано на шине _D_out_ через такт опорной частоты после фронта сигнала на шине _addr_.

Для записи значения в служебный регистр блока необходимо сформировать:

* на порт _addr_ -- адрес выбранного регистра,
* на шине _D_in_ -- записываемую информацию,
* на порт _wr_en_ -- значение 1.

Запись в регистр полученных (*buffered_data_r*) данных игнорируется.

Также на на шине d_out через такт опорной частоты _clk_ после фронта сигнала на шине _addr_ будет сформировано значение записанного регистра. Значение шины d_out будет соответствовать значению последнего опрошенного или записанного регистра до формирования следующего запроса.

image::image_SlReciever_read_write_waveform.png[title="Временная диаграмма чтения и записи регистров модуля SlReciever", align="center"]

[[rec_addr_table]]
.Адреса регистров
[cols="2*^", width=99%]
|===
|Значение сигнала _addr_  | Выбранный регистр
|b0                       | регистр данных (*buffered_data_r*)
|b1                       | служебный регистр (*config_status_r*)
|===



=== Прием сообщений

Для приема сообщений необходимо:

. Записать в регистр *config_r* необходимые настройки частоты и длины слова (см. раздел "<<rec_config_change, Смена конфигурации>>")
. Записать в регистр данных сообщение на отправку
. Дождавшись запроса на прерывания вызванного успешным приемом сообщения, или, работая по таймеру и периодически опрашивая регистр состояния, убедится, что сообщение было принято  (*IRQRM* == 1).
. Считать принятое сообщение из регистра полученных данных (*buffered_data_r*).
. Сбросить поле причины прерывания *IRQRM*. Возможна работа без сбрасывания поля *IRQRM*, но тогда вы не сможете отличить заново принятое сообщение от принятого в прошлый раз.
. Ожидать следующее сообщение.

В случае когда поле BC служебного регистра не равно 32, принятым сообщением являются младшие разряды регистра данных (*buffered_data_r [BC-1:0]*).

Успешным приемом сообщения называется прием сообщения с совпадающим со значением поля
*BC* количеством информационных разрядов и, если включен контроль четности (*PCE* = 1), верной четностью.

В случае, если успешно принято слово с правильной четностью выставляются разряды *IRQRM* = 1 и *WRP* = 0. Если контроль четности отключен и принято слово с неправильной четностью, выставляются разряды *IRQPEM* = 1, *PEF* = 1 и  *WRP* = 0.

=== Прием сообщений с ошибкой

В случае приема сообщения с ошибкой выставляются следующие разряды:

* Если контроль четности включен и принято сообщение с ошибкой четности -- *IRQPEM* = 1
* Принято сообщение с несовпадающим с конфигурацией количеством разрядов -- *IRQWLC* = 1

Регистр данных при этом не обновляется и продолжает хранить последнее успешно принятое сообщение.

В случае, если во время приема произошла ошибка уровня, выставляется флаг *IRQLEF* = 1.
Модуль вернется в режим ожидания сообщения только когда уровень на линиях будет восстановлен.
До этого момента попытка сброса  разряда причины прерывания *IRQLEF* будет игнорирована.

[[rec_config_change]]
=== Смена конфигурации

В конфигурационной части служебного регистра могут быть установлены контроль четности, длина слова, маскировка причин запроса прерывания или осуществлен сброс модуля к исходным настройкам.

Для изменения конфигурации приемник необходимо записать новые параметры в служебный регистр. Если изменение конфигурации происходит во время приема сообщения, то прием не прерывается, при поступлении синхроимпульса корректность принятого.

В случае, если во время приема произошла попытка изменить поля *PCE* и *BC* и новая
 конфигурация неверна, выставляется разряды *IRQICC*, поля *PCE* и *BC* остаются неизменными.

Некорректной считается конфигурация с нечетными длинами слова или длиной слова лежащей вне промежутка от 8 до 32 разрядов. При попытке записать подобную конфигурацию будет выставлен разряд *IRQICC* = 1, а поля *BC* и *PCE* останутся неизменными.

=== Работа с прерываниями

Запрос прерывания происходит, когда произошло одно из событий и разряд причины прерываний соответствующий этому событию не замаскирован. Узнать какое именно событие вызвало запрос на прерывание можно в <<rec_status_part_table,полях причин прерываний>> служебного регистра.

[[trans_irq_events]]
.События соответствующие разрядам причин прерываний
* *IRQRM* -- Было принято полностью корректное сообщение
* *IRQPEM* -- Было принято сообщение с верной длинной и ошибкой четности
* *IRQWLC* -- Было принято сообщение не прошедшее проверку длины полученного слова.
* *IRQLEF* -- Во время приема сообщения произошла ошибка уровня на линии (равенство полю *BC*)
* *IRQICC* -- Была предпринята попытка записать некорректную конфигурацию в конфигурационный регистр

//не прошедшего проверку длины полученного слова.
//на равенство значению BC регистра config_r

Для сброса прерывания необходимо записать 0 в разряды причин прерываний, которые необходимо сбросить.

Более подробно работа прерываний рассмотрена в разделе <<rec-work-algorythm, Алгоритм работы>>.


=== Выключение модуля

Чтобы выключить модуль необходимо записать 1 в разряд *SR* служебного регистра.

Если сделать это во время отправки сообщения, прием прекращается. Служебный регистр возвращается в начальное состояние, регистр данных сбрасывается.


[[rec-work-principle]]
== Принцип работы
На каждом такте значение со входов записывается в сдвиговые регистры линий _SL0_ или _SL1_.

Прием сообщения обеспечивается двумя состояниями: ожидания импульса и приема импульса. Переход между состояниями происходит когда содержимое сдвиговых регистров линий соотвествует маске, таким образом устраняется дребезг сигнала.

В состоянии обработки импульса используется счетчик количества циклов. По нему проверяется длинна импульса - если импульс слишком короткий или слишком длинный, ожидается конце импульса, а следующий импульс воспринимается как импульс нового сообщения.

Импульс обрабатывается через определенное количество тактов с момента зафиксированного начала импульса. Если импульс является импульсом разряда, то разряд добавляется в сдвиговый регистр сообщения и регистр сдвигается, новый разряд учитывается в проверке четности. Если импульс является синхроимпульсом, то содержимое сдвигового регистра сообщения и счетчика количества разрядов проверяются на соответствие подсчитанный четности и сконфигурированному количеству разрядов.

[[rec-work-Algorythm]]
== Алгоритм работы
image::image_SlReciever_irq_algorithm.png[title="Алгоритм работы регистра состояния модуля SlReciever", align="center"]
Модуль может находиться в двух режимах: режим приема и режим ожидания. После включения модуля, все разряды регистра состояния устанавливаются в 0, модуль
находится в режиме ожидания.

*Смена конфигурации и сброс прерываний в режиме ожидания*

Чтобы сменить конфигурацию, необходимо записать новую конфигурацию в регистр конфигурации и состояния.
При записи регистра конфигурации и состояния в  режиме ожидания происходит проверка
битов причин прерываний: если значения соответствующих записываемых битов прерываний равны 0,
то они сбрасываются.

Если конфигурация некорректна, выставляется IRQICС = 1,
конфигурация не изменяется. Если бит IRQICC не замаскирован
формируется запрос на прерывание.

Если конфигурация корректна она записывается в регистр.
Модуль остается в режиме ожидания.

*Прием сообщения*

Если на одной из линий возникает импульс. модуль переходит в режим приема,
устанавливается поле  регистра состояний WRP = 1.
Если импульс слишком короткий или слишком длинный, возникает ошибка уровня,
выставляется бит IRQLE = 1. Бит выставляется каждый такт, пока уровень на линии не будет восстановлен.
После этого модуль возвращается в режим отправки сообщения, выставляется бит  WRP = 0.

Если импульс является синхроимпульсом модуль выставляет соответствующие принятому сообщению
биты статусного регистра и, если сообщение принято успешно, запоминает сообщение
в регистр данных, выставляется бит WRP = 0.

*Анализ принятого сообщения*

При приеме синхроимпульса (условие END_OF_MSG на рис. 1) сначала проверяется длинна
принятого сообщения, если длинна не совпадает с конфигурацией (значение поля BC + 1 за счет бита четности) выставляется IRQWLC = 1.
Если бит IRQWLC не замаскирован, формируется запрос на прерывание.

Если длинна совпадает с выставленной в конфигурации, проверяется четность полученного сообщения.
Если четность верна, сообщение считается успешно принятым, выставляется IRQRM = 1, содержимое сдвигового регистра с удаленным битом четности
записывается в регистр данных. Если бит IRQRM не замаскирован, формируется запрос на прерывание.

Если четность неверна, выставляется бит IRQPEM = 1. Однако, если контроль четности отключен,
сообщение все равно считается успешно принятым, данные сдвигового регистра с удаленным битом четности переписываются
в регистр данных. Выставляется бит PEF = 1.  Если бит IRQPEM не замаскирован, формируется запрос на прерывание.

*Дублирование битов проверки честности*

Бит причины прерывания IRQPEM и бит четности PEF дублируют функции друг друга.
Тем не менее эта система необходима для разрешения следующего конфликта:
Допустим с приемником с отключенным контролем четности, и за время, прошедшее с последнего
опроса пришло 2 сообщения, одно с верной четностью, а другое с ошибкой.
Тогда флаг PEF - единственный способ определить, верна ли честность сообщения, лежащего в
регистре данных.

*Изменение конфигурации и сброс прерываний во время приема сообщения*

Когда модуль находится в режиме приема сообщения, то без отмены приема возможно только изменение полей маскирования прерываний, и сброс битов причин прерываний.
Если изменить длину сообщения в середине приема сообщения, прием сообщения будет отменен, а остаток сообщения будет воспринят как новое сообщение неправильной длинны.

Если в режиме отправки происходит запись регистра конфигурации и состояния,
сначала проверяются биты прерываний: если значения соответствующих записываемых
битов прерываний равны 0, то они сбрасываются. После этого, проверяется изменяются
ли биты конфигурации (поля PCE, BC). Если они не изменяются, модуль остается
в режиме приема сообщения. Если они изменяются то прием завершается, выставляются
биты WRP = 0 и IRQWCC = 1. Если бит IRQDWСС не замаскирован формируется запрос на прерывание.
 Если конфигурация корректна, она записывается в регистр,
если же нет, выставляется бит IRQICC = 1.
Модуль переходит в режим ожидания сообщения.

*Формирование запроса на прерывание*

Запрос на прерывание формируется на выходе irq, через один такт после возникновения причины прерывания,
если причина этого прерывания не замаскирована в поле IRQM.

image::image_SlReciever_Recieve_algorithm.png[title="Алгоритм работы приема сообщения модуля SlReciever", align="center"]

После включения приемника сдвиговый регистр приема сообщения shift_r заполняется нулями,
Сдвиговых регистры sl_0_tmp и sl_1_tmp - единицами,
счетчик количества бит bit_i устанавливается в 0,
счетчик циклов cycle_i устанавливается в 0,
регистры контроля четности par_0 и par_1 устанавливаются в 0 и 1 соотвественно.

Каждый такт значение с асинхронных входов serial_line_zeroes_a и serial_line_ones_a
помещаются в нулевые разряды сдвиговых регистров sl_0_tmp и sl_1_tmp. Остальные разряды
при этом сдвигаются. Условия bit_started, и bit_ended получаются при сравнении содержимого sl_0_tmp и sl_1_tmp c масками.

.Условия переходов
[cols="2*^", width=99%]
|===
|Обозначение               | Выражение
|bit_started               | (sl0_tmp_r == 12'hF??0) \|\| (sl1_tmp_r == 12'hF??0)
|bit_ended                 | (sl0_tmp_r = =12'h0??F) \|\| (sl1_tmp_r == 12'h0??F)
|===

.Значения констант счетчика cycle_i
[cols="2*^", width=99%]
|===
|Обозначение               | Значение
|const_1                   | 3
|const_2                   | 32
|===
*Состояние BIT_WAIT_FLUSH*

В начале приема машина состояний находится в состоянии BIT_WAIT_FLUSH.
В этом состоянии счетчик циклов приравнивается к константе const1. Если выполняется условие bit_started,
происходит переход в состояние BIT_DETECTED.

*Состояние BIT_DETECTED*

В состоянии BIT_DETECTED работает счетчик циклов cycle_i.
Как только этот счетчик становится равным до 0, производится анализ, какой именно бит принят,
и в зависимости от
значения первых разрядов сдвиговых регистров sl_0_tmp и sl_1_tmp  определяется,
на какую из линий поступил импульс и происходит переход в состояние обработки бита BIT_PROCESSING.
При этом, если импульс отсутствует, происходит переход в состояние LEV_ERR.

*Состояние BIT_PROCESSING*

В состоянии BIT_PROCESSING проверяется, на какую из линий пришел импульс.

Если импульс на линии нулей или на линии единиц соответствующее значение 0 или 1 загружаются в бит
с номером BC сдвигового регистра shift_r. Сам сдвиговый регистр при этом сдвигается вправо.
В состоянии если импульс на линии единиц инвертируется значение бита четности единиц par_1, а если на линии нулей - значение par_0.
В регистр cycle_i помещается значение const2. Счетчик принятых bit_i инкрементируется.

Если же импульсы на обоих линиях, то модуль считает, что это синхроимпульс.
Сравнивается количество принятых бит с установленным в конфигурации,
Проверяется четность. Если количество бит и четность верны, или, если верно количество бит,
контроль честности отключен и не верна четность, значение из сдвигового регистра shift_r переписывается
в регистр данных c обнулением бита четности shift_r[BC].

В случае синхроимпульса для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 1. par_1 = 0.
В регистр cycle_i помещается значение const_2.

*Особенности контроля честности*

Считая бит честности, количество импульсов на линии единиц с учетом разряда четности должно быть нечетным, а на линии нулей - четным.

Для проверки этого, до приема сообщения в регистры подсчета четности загружаются значения par_0 = 0. par_1 = 1.
При принятии единицы меняет значение на противоположное регистр par_1, а при принятии нуля -- par_0.

Таким образом, после принятия всех бит корректного сообщения (считая бит четности),
регистр par_0 должен поменять свое значение четное количество раз, т.е. сохранить значение par_0 = 0,
а регистр par_1 свое значение нечетное количество раз, т.е. приобрести значение par_1 = 0.

При обработке стоп бита считается, что четность нарушена, если хотя бы один из регистров par_0 и par_1 не равен нулю.

*Состояние WAIT_BIT_END*

После обработки импульса в состояниях ONE_BIT, ZERO_BIT или STOP_BIT, схема переходит в состояние WAIT_BIT_END.
Модуль находится в этом состоянии, пока счетчик cycle_i не достиг нулевого значения, или не выполниться условие bit_ended.

Если выполнилось условие bit_ended, модуль возвращается в состояние BIT_WAIT_FLUSH. Если же счетчик досчитал до нулевого значения,
это значит, что импульс не закончился вовремя, и произошла ошибка уровня на линии - модуль переходит в состояние LEV_ERR.

*Состояние LEV_ERR*

Модуль оказывается в состоянии LEV_ERR в случаях, когда длинна импульса оказалось слишком большой или слишком маленькой,
т.е. произошла ошибка уровня на линии. Когда уровень на обоих линиях восстановлен, модуль переходит в состояние BIT_WAIT_FLUSH.
Для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 0 и par_1 = 1.

<<<
// [[rec-state-machine]]
// == Конечный автомат
// image::image_SlReciever_SM.png[title="Конечный автомат модуля SlReciever", align="center"]
// После включения
//
// Каждый такт значение асинхронных входов serial_line_zeroes_a и serial_line_ones_a
// загружается в в первый разряд сдвиговых регистров sl0_tmp_r[15:0] и sl1_tmp_r[15:0],
// регистры сдвигаются.
//
// Когда прием сообщения не начат, модуль находится в состоянии BIT_WAIT_FLUSH,
//  регистр счетчиков бит = 0,
