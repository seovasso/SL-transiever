= Спецификация модуля приемника SL-канала :SlReciever
//===========
// Compile:
// evgeniy@N7-63:~/Documents/2015VV024/doc$ asciidoctor-pdf -a pdf-style=/home/evgeniy/Documents/RISC-V/fizika-theme.yml -a pdf-fontsdir=/home/evgeniy/Downloads/fonts/Combo/ ./src/2015VV024_datasheet.adoc && mv ./src/2015VV024_datasheet.pdf ./ && evince ./2015VV024_datasheet.pdf
:Authors: Василий Мочалов
:Email:   seovasso@gmail.com
:Date:      13.10.2017
:Revision:  0.3
:toc:       right
:toclevels: 3
:source-highlighter: rouge
:table-caption:     Таблица
:listing-caption:   Код
:chapter-label:     Глава
:toc-title:         Оглавление
:version-label:     Версия
:figure-caption:    Рисунок
:imagesdir:         ./../img/
:sectnums:
:sectnumlevels: 3
:revnumber: 1.1
:revdate:   15.12.2017
:revremark: Рабочая версия
[[rec-main-description]]
== Описание
Данный проект подразумевает реализацию RTL-описания на языке Verilog одноканального приемника SL-канала. Приемник принимает SL-сообщения. Сообщения могут содержать информацию четной разрядности от 8 до 32 бит. Бит четности проверется автоматически. Приемник способен принимать сообщения с частотой импульсов от 500кГц до 2МГц (при частоте тактового сигнала = 16МГц).

[[rec-top-level-description]]
== Описание верхнего уровня
.Порты цифрового модуля SlReciever
[cols="3*^1,1*^2,1*<3", halign="left", width=99%]
|===
|Название      |Тип   |Разрядность |Значение после сброса |Описание
|_rst_n_       |In    |1           | -                    |Асинхронный общий сигнал сброса
|_clk_         |In    |1           | -                    |Сигнал тактовой частоты
|_addr_        |In    |1           | -                    |Сигнал выбора регистра
|_wr_en_       |In    |1           | -                    |Сигнал разрешения записи
|_SL0_         |In    |1           |b1                    |Сигнал нулей SL канала
|_D_in_        |In    |32          | -                    |Данные для записи в регистры
|_SL1_         |in    |1           |b1                    |Сигнал единиц SL канала
|_irq_         |Out   |1           |b0                    |Сигнал запроса на прерывание
|_D_out_       |Out   |32          |h0000_0000            |Данные для чтения регистров
|===

<<<

[[rec-programm-model]]
== Программная модель
Пользователю для работы доступно два регистра:

* Служебный (*config_status_r*)
* Данных к отправке (*buffered_data_r*)

=== Служебный регистр

Служебный регистр состоит из двух частей - конфигурации и состояния. Части отвечающей за конфигурацию соответствуют младшие 16 разрядов, части состояния старшие.

[[rec_conf_table]]
.Назначение разрядов конфигурационной части служебного регистра (*config_status_r [15:0]*)
[cols="16*^", width=99%]
|===
|Bit        |15-14  |13 |  12 |11 |10 |9  |8   |7       |6 |5 |4 |3 |2 |1 |0
|Name       |-    6+|*IRQM[5:0]*               |*PCE* 6+|*BC[5:0]*        |*SR*
|Mode       |R    6+|R/W                       |R/W   6+|R/W              |R/W
|Initial    |0      |0  |0    |0  |0  |0  |0   |0       |0 |0 |1 |0 |0 |0 |0
|===

.Описание разрядов регистра конфигурационной части служебного регистра (*config_status_r [15:0]*)
. *SR* (soft reset) -- включает (*SR* = 0) и выключает (*SR* = 1) приемник
. *BC* (bit count) -- количество разрядов данных в отправляемом сообщении
. *IRQM* (interrupt request mask) -- маска разрядов причин прерываний.
  Задает, какие именно разряды причин прерываний вызывают запрос на прерывание. Описание разрядов причин прерываний можно посмотреть в <<rec_IRQM_table,таблице назначения разрядов части состояния служебного регистра>>. Соответствие разрядов поля IRQM и разрядов причин прерываний можно посмотреть в соответствующей <<rec_IRQM_table, таблице>>
. *PCE* (parity check enable) -- включение (*PCE* = 1) или выключение(*PCE* = 0) контроля четности

.Назначение разрядов части состояния служебного регистра (*config_status_r [31:16]*)
[cols="11*^", width=99%]
|===
|Bit     |31-30  |29       |28       |27       |26       |25       |24      |23-18 |17    |16
|Name    |-      |*IRQICC* |*IRQWCC* |*IRQLE*  |*IRQWLC* |*IRQPEM* |*IRQRM* |-     |*PEF* |*WRP*
|Mode    |R      |R/W0     |R/W0     |R/W0     |R/W0     |R/W0     |R/W0    |R     |R     |R
|Initial |0      |0        |0        |0        |0        |0        |0       |0     |0     |0
|===

.Описание разрядов части состояния служебного регистра (*config_status_r [31:16]*)
. *WRP* - (word receiving process) -- разряд идущего процесса приема слова по SL-каналу.
. *PEF* - (parity error flag) -- разряд наличия ошибки четности в хранящемся в буфере сообщении.
. *IRQRM* - (interrupt request of recieved message) -- разряд запроса на прерывание успешно принятого сообщения.
. *IRQPEM* - (interrupt request of parity error message) -- разряд запроса на прерывание принятия слова не прошедшего проверку четности.
. *IRQWLC* - (interrupt request of word length check) --  разряд запроса на прерывание принятия слова неверной длинны.
//не прошедшего проверку длины полученного слова.
//на равенство значению BC регистра config_r
. *IRQLE* - (interrupt request of level error on line) -- разряд запроса на прерывание ошибки уровня напряжения на линии SL-канала.
. *IRQWCC* (interrupt request of wrong configuration change) -- разряд запроса на прерывание попытки сменить конфигурацию во время приема сообщения.
. *IRQICC* (interrupt request of incorrect  configuration change ) -- разряд запроса на прерывание попытки установить некорректную конфигурацию.

Разряды *IRQRM*, *IRQPEM*, *IRQWL*, *IRQLE*, *IRQWCC* и *IRQICC* отражают зарегистрированные приемником события. Более подробно события описаны разделе Работа с программной моделью -> <<rec_irq_events, Работа с прерываниями>>.

[[rec_IRQM_table]]
.Соответствие разрядов <<rec_conf_table,*IRQM [5:0]*>> и маскирования разрядов причин прерываний
[cols="2*^", width=99%]
|===
|Разряд поля *IRQM*       |Маскируемый разряд
|*IRQM0*                  |*IRQRM*
|*IRQM1*                  |*IRQPEM*
|*IRQM2*                  |*IRQWLC*
|*IRQM3*                  |*IRQLE*
|*IRQM4*                  |*IRQWCC*
|*IRQM5*                  |*IRQICC*
|===

=== Регистр полученных данных

.Назначение разрядов регистра полученных данных (*buffered_data_r*)
[cols="2*^", width=99%]
|===
|Bit     |31 - 0
|Name    |*DATA*
|Mode    |R
|Initial |0
|===
.Описание разрядов регистра полученых данных (*buffered_data_r*)
*DATA* - полученные данные


== Описание работы

Модуль принимает SL-сообщения. Сообщения могут иметь четную длинну от 8 до 32 бит.
Бит четности проверяется автоматически. Частота импульсов принимаемых сообщений может меняться от 500кГц
до 2МГц (при частоте тактового сигнала = 16МГц).

*Запись и чтение регистров*

Управление модулем осуществляется путем записи/чтения регистров.

Для считывания текущего значения одного из регистров блока необходимо сформировать на шине addr соответствующее ему значение,
указанное в таблице, длительностью не меньше такта опорной тактовой частоты.
Значение регистра будет сформировано на шине d_out через такт опорной после фронта сигнала на шине addr.

Для записи значения в один из регистров блока необходимо сформировать:

* на шине addr значение соответствующее регистру
* на шине d_in записываемую информацию,
* на порт wr_en - значение "1".

Также на на шине d_out через такт опорной после фронта сигнала на шине addr будет сформировано значение записанного регистра.
Значение шины d_out будет соответствовать значению последнего опрошенного или записанного регистра до формирования следующего запроса.

.Адреса регистров
[cols="2*^", width=99%]
|===
|Значение шины addr | Выбранный регистр
|1'b0               | регистр данных
|1'b1               | регистр конфигурации и состояния
|===

*Смена конфигурации*

Для изменения конфигурации приемника необходимо перезаписать регистр конфигурации и состояния.
В конфигурационной части может быть установлена длинна слова,
 маскировка причин запроса прерывания или осуществлен сброс модуля к исходным настройкам.
Неверной считается конфигурация с нечетными длинами слова или длинной слова лежащей вне промежутка от 8 до 32 бит.

*Прием сообщений*

Если на вход модуля начинают поступать импульсы, модуль переходит в режим приема сообщения,
выставляется бит WRP = 1.

Модуль переходит в режим ожидания нового сообщения в ситуациях:

* Успешного приема сообщения
* Приема сообщения с ошибкой
* Завершившейся ошибки уровня на линии
* Попытки изменить конфигурацию модуля во время приема сообщения

//При переходе

Успешным приемом сообщения называется прием сообщения с совпадающим со значением поля
BC количеством информационных бит и, если включен контроль четности, верной четностью.

В случае, если успешно принято слово с правильной четностью выставляются биты IRQRM = 1 и WRP = 0.
Если контроль четности отключен и принято слово с неправильной четностью, выставляются биты
IRQPEM = 1, PEF = 1 и  WRP = 0.

В случае приема сообщения с ошибкой выставляются биты:

* Контроль четности включен и принято сообщение с ошибкой четности -- IRQPEM = 1 и  WRP = 0
* Принято сообщение с несовпадающим с конфигурацией количеством бит -- IRQWLC = 1 и  WRP = 0

В случае, если во время приема произошла ошибка уровня, выставляется флаг IRQLEF = 1.
Модуль вернется в режим ожидания сообщения только когда уровень на линиях будет восстановлен.
До этого момента будет флаг WRP = 1, а бит причины прерывания IRQLEF будет невозможно сбросить.

В случае, если во время приема произошла попытка изменить поля PCE и BC регистра конфигурации,
выставляются биты IRQWCC = 1 и WRP = 0. Если новая конфигурация верна, она записывается в регистр.
Если новая конфигурация неверна, выставляется бит IRQICC, поля PCE и BC остаются неизменными.

В регистре данных всегда хранится последнее успешно принятое сообщение.
А в поле PEF регистра состояния - наличие ошибки четности последнего успешно принятого сообщения.

После считывания сообщения необходимо сбросить возникшие биты причин прерываний, и ожидать приема следующего сообщения.

*Прерывания*

Запрос прерывания происходит произошло одно из событий и бит этого события не замаскирован :

* Успешно принято сообщение (IRQRM)
* Принято сообщение с ошибкой четности (IRQPEM)
* Принято сообщение неверной длинны (IRQWLC)
* Произошла ошибка уровня на линии (IRQLE)
* Была предпринята попытка записать некорректные данные в конфигурационный регистр (IRQICC)
* Изменение конфигурации в процессе отправки сообщения (IRQWCC)


Причину возникновения можно посмотреть  в соответствующих полях регистра состояния.
Для сбрасывания прерываний, вам необходимо считать регистр конфигурации и состояния и
записать считанное снова, занулив биты прерываний. Более подробно работа прерываний
рассмотрена в разделе Алгоритм работы.


*Выключение модуля*

Чтобы выключить модуль необходимо выставить поле регистра конфигурации SR = "1".
Если сделать это во время отправки сообщения, прием сообщения прекращается.
Регистры конфигурации и состояния возвращаются в начальное состояние.
Когда приемник выключен, он не реагирует на сигналы на входах SL0 и SL1.

<<<
[[rec-irq-Algorythm]]
== Алгоритмы работы
image::image_SlReciever_irq_algorithm.png[title="Алгоритм работы регистра состояния модуля SlReciever", align="center"]
Модуль может находиться в двух режимах: режим приема и режим ожидания. После включения модуля, все биты регистра состояния устанавливаются в 0, модуль
находится в режиме ожидания.

*Смена конфигурации и сброс прерываний в режиме ожидания*

Чтобы сменить конфигурацию, необходимо записать новую конфигурацию в регистр конфигурации и состояния.
При записи регистра конфигурации и состояния в  режиме ожидания происходит проверка
битов причин прерываний: если значения соответствующих записываемых битов прерываний равны 0,
то они сбрасываются.

Если конфигурация некорректна, выставляется IRQICС = 1,
конфигурация не изменяется. Если бит IRQICC не замаскирован
формируется запрос на прерывание.

Если конфигурация корректна она записывается в регистр.
Модуль остается в режиме ожидания.

*Прием сообщения*

Если на одной из линий возникает импульс. модуль переходит в режим приема,
устанавливается поле  регистра состояний WRP = 1.
Если импульс слишком короткий или слишком длинный, возникает ошибка уровня,
выставляется бит IRQLE = 1. Бит выставляется каждый такт, пока уровень на линии не будет восстановлен.
После этого модуль возвращается в режим отправки сообщения, выставляется бит  WRP = 0.

Если импульс является синхроимпульсом модуль выставляет соответствующие принятому сообщению
биты статусного регистра и, если сообщение принято успешно, запоминает сообщение
в регистр данных, выставляется бит WRP = 0.

*Анализ принятого сообщения*

При приеме синхроимпульса (условие END_OF_MSG на рис. 1) сначала проверяется длинна
принятого сообщения, если длинна не совпадает с конфигурацией (значение поля BC + 1 за счет бита четности) выставляется IRQWLC = 1.
Если бит IRQWLC не замаскирован, формируется запрос на прерывание.

Если длинна совпадает с выставленной в конфигурации, проверяется четность полученного сообщения.
Если четность верна, сообщение считается успешно принятым, выставляется IRQRM = 1, содержимое сдвигового регистра с удаленным битом четности
записывается в регистр данных. Если бит IRQRM не замаскирован, формируется запрос на прерывание.

Если четность неверна, выставляется бит IRQPEM = 1. Однако, если контроль четности отключен,
сообщение все равно считается успешно принятым, данные сдвигового регистра с удаленным битом четности переписываются
в регистр данных. Выставляется бит PEF = 1.  Если бит IRQPEM не замаскирован, формируется запрос на прерывание.

*Дублирование битов проверки честности*

Бит причины прерывания IRQPEM и бит четности PEF дублируют функции друг друга.
Тем не менее эта система необходима для разрешения следующего конфликта:
Допустим с приемником с отключенным контролем четности, и за время, прошедшее с последнего
опроса пришло 2 сообщения, одно с верной четностью, а другое с ошибкой.
Тогда флаг PEF - единственный способ определить, верна ли честность сообщения, лежащего в
регистре данных.

*Изменение конфигурации и сброс прерываний во время приема сообщения*

Когда модуль находится в режиме приема сообщения, то без отмены приема возможно только изменение полей маскирования прерываний, и сброс битов причин прерываний.
Если изменить длину сообщения в середине приема сообщения, прием сообщения будет отменен, а остаток сообщения будет воспринят как новое сообщение неправильной длинны.

Если в режиме отправки происходит запись регистра конфигурации и состояния,
сначала проверяются биты прерываний: если значения соответствующих записываемых
битов прерываний равны 0, то они сбрасываются. После этого, проверяется изменяются
ли биты конфигурации (поля PCE, BC). Если они не изменяются, модуль остается
в режиме приема сообщения. Если они изменяются то прием завершается, выставляются
биты WRP = 0 и IRQWCC = 1. Если бит IRQDWСС не замаскирован формируется запрос на прерывание.
 Если конфигурация корректна, она записывается в регистр,
если же нет, выставляется бит IRQICC = 1.
Модуль переходит в режим ожидания сообщения.

*Формирование запроса на прерывание*

Запрос на прерывание формируется на выходе irq, через один такт после возникновения причины прерывания,
если причина этого прерывания не замаскирована в поле IRQM.

image::image_SlReciever_Recieve_algorithm.png[title="Алгоритм работы приема сообщения модуля SlReciever", align="center"]

После включения приемника сдвиговый регистр приема сообщения shift_r заполняется нулями,
Сдвиговых регистры sl_0_tmp и sl_1_tmp - единицами,
счетчик количества бит bit_i устанавливается в 0,
счетчик циклов cycle_i устанавливается в 0,
регистры контроля четности par_0 и par_1 устанавливаются в 0 и 1 соотвественно.

Каждый такт значение с асинхронных входов serial_line_zeroes_a и serial_line_ones_a
помещаются в нулевые разряды сдвиговых регистров sl_0_tmp и sl_1_tmp. Остальные разряды
при этом сдвигаются. Условия bit_started, и bit_ended получаются при сравнении содержимого sl_0_tmp и sl_1_tmp c масками.

.Условия переходов
[cols="2*^", width=99%]
|===
|Обозначение               | Выражение
|bit_started               | (sl0_tmp_r == 12'hF??0) \|\| (sl1_tmp_r == 12'hF??0)
|bit_ended                 | (sl0_tmp_r = =12'h0??F) \|\| (sl1_tmp_r == 12'h0??F)
|===

.Значения костант счетчика cycle_i
[cols="2*^", width=99%]
|===
|Обозначение               | Значение
|const_1                   | 3
|const_2                   | 32
|===
*Состояние BIT_WAIT_FLUSH*

В начале приема машина состояний находится в состоянии BIT_WAIT_FLUSH.
В этом состоянии счетчик циклов приравнивается к константе const1. Если выполняется условие bit_started,
происходит переход в состояние BIT_DETECTED.

*Состояние BIT_DETECTED*

В состоянии BIT_DETECTED работает счетчик циклов cycle_i.
Как только этот счетчик становится равным до 0, производится анализ, какой именно бит принят,
и в зависимости от
значения первых разрядов сдвиговых регистров sl_0_tmp и sl_1_tmp  определяется,
на какую из линий поступил импульс и происходит переход в состояние обработки бита BIT_PROCESSING.
При этом, если импульс отсутствует, происходит переход в состояние LEV_ERR.

*Состояние BIT_PROCESSING*

В состоянии BIT_PROCESSING проверяется, на какую из линий пришел импульс.

Если импульс на линии нулей или на линии единиц соответствующее значение 0 или 1 загружаются в бит
с номером BC сдвигового регистра shift_r. Сам сдвиговый регистр при этом сдвигается вправо.
В состоянии если импульс на линии единиц инвертируется значение бита четности единиц par_1, а если на линии нулей - значение par_0.
В регистр cycle_i помещается значение const2. Счетчик принятых bit_i инкрементируется.

Если же импульсы на обоих линиях, то модуль считает, что это синхроимпульс.
Сравнивается количество принятых бит с установленным в конфигурации,
Проверяется четность. Если количество бит и четность верны, или, если верно количество бит,
контроль честности отключен и не верна четность, значение из сдвигового регистра shift_r переписывается
в регистр данных c обнулением бита четности shift_r[BC].

В случае синхро импульса для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 1. par_1 = 0.
В регистр cycle_i помещается значение const_2.

*Особенности контроля честности*

Считая бит честности, количество импульсов на линии единиц с учетом разряда четности должно быть нечетным, а на линии нулей - четным.

Для проверки этого, до приема сообщения в регистры подсчета четности загружаются значения par_0 = 0. par_1 = 1.
При принятии единицы меняет значение на противоположное регистр par_1, а при принятии нуля -- par_0.

Таким образом, после принятия всех бит корректного сообщения (считая бит четности),
регистр par_0 должен поменять свое значение четное количество раз, т.е. сохранить значение par_0 = 0,
а регистр par_1 свое значение нечетное количество раз, т.е. приобрести значение par_1 = 0.

При обработке стоп бита считается, что четность нарушена, если хотя бы один из регистров par_0 и par_1 не равен нулю.

*Состояние WAIT_BIT_END*

После обработки импульса в состояниях ONE_BIT, ZERO_BIT или STOP_BIT, схема переходит в состояние WAIT_BIT_END.
Модуль находится в этом состоянии, пока счетчик cycle_i не достиг нулевого значения, или не выполниться условие bit_ended.

Если выполнилось условие bit_ended, модуль возвращается в состояние BIT_WAIT_FLUSH. Если же счетчик досчитал до нулевого значения,
это значит, что импульс не закончился вовремя, и произошла ошибка уровня на линии - модуль переходит в состояние LEV_ERR.

*Состояние LEV_ERR*

Модуль оказывается в состоянии LEV_ERR в случаях, когда длинна имульса оказалось слишком большой или слишком маленькой,
т.е. произошла ошибка уровня на линии. Когда уровень на обоих линиях восстановлен, модуль переходит в состояние BIT_WAIT_FLUSH.
Для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 0 и par_1 = 1.

<<<
// [[rec-state-machine]]
// == Конечный автомат
// image::image_SlReciever_SM.png[title="Конечный автомат модуля SlReciever", align="center"]
// После включения
//
// Каждый такт значение асинхронных входов serial_line_zeroes_a и serial_line_ones_a
// загружается в в первый разряд сдвиговых регистров sl0_tmp_r[15:0] и sl1_tmp_r[15:0],
// регистры сдвигаются.
//
// Когда прием сообщения не начат, модуль находится в состоянии BIT_WAIT_FLUSH,
//  регистр счетчиков бит = 0,
