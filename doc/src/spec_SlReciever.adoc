= SlReciever
:Date:      13.10.2017
:Revision:  0.1
:toc:       right
:icons:     font
:source-highlighter: rouge
:table-caption:     Таблица
:listing-caption:   Код
:chapter-label:     Глава
:toc-title:         Оглавление
:version-label:     Версия
:figure-caption:    Рисунок
:imagesdir:         ./../img/

[[rec-main-description]]
== Описание
Данный проект подразумевает реализацию RTL-описания на языке Verilog одноканального приемника SL-канала.

[[rec-top-level-description]]
== Описание верхнего уровня

[[rec-input-signals]]
=== Входные сигналы
* rst_n - асинхронный общий сигнал сброса
* clk - сигнал тактовой частоты
* [31:0] D_in - порт для записи данных в регистры
* wr_en - После установки в 1 в выбранный портом addr регистр записывается необходимое число
* addr - адрес регистра "0" - регистр данных, "1" - регистр конфигурации и состояния
* serial_line_zeroes_a - асинхронный вход линии нулей SL-канала
* serial_line_ones_a - асинхронный вход линии единий SL-канала

[[rec-output-signals]]
=== Выходные сигналы
* [31:0] D_out - порт для чтения регистров
* irq - вывод прерывания

[[rec-inout-signals]]
=== Двунаправленные сигналы

Отсутствуют.

[[rec-programm-model]]
== Программная модель
Пользователю для работы доступно несколько регистров:

* Регистр конфигурации и состояния (config_r и status_r)
* Регистр последнего успешно принятого сообщения (buffered_data_r)

=== Регистр конфигурации и состояния

Регистр конфигурации и состояния состоит из двух объединеных  регистров -
регистра конфигурации и регистра состояния. Регистру конфигурации соответвуют младшие 16 разрядов, регистру состояния - старшие.

.Назначение разрядов регистра конфигурации  (config_r)
[cols="16*^", width=99%]
|===
|0     |1     |2 |3 |4 |5 |6    |7      |8    |9      |10   |11   |12   |13   |14    |15
|SR  6+|BC[6:0]                 |PCE  6+|IRQM                                 |Res*  |Res*
|===

.Описание разрядов регистра конфигурации (config_r)
. SR - soft reset, включает (SR=1) и выключает (SR=0) приемник
. BC - bit count, количество бит в слове
. IRQM - interrupt request mask, маскирование прерываний модуля
. PCE - parity check enable, разрешение контроля четности(PCE = 1), или запрещение(PCE = 0)

.Связь разрядов IRQM и маскирования причин прерываний
[cols="2*^", width=99%]
|===
|Разряд поля IRQM     | Маскируемый бит
|IRQM[0]              |IRQRM
|IRQM[1]              |IRQPEM
|IRQM[2]              |IRQWLC
|IRQM[3]              |IRQLE
|IRQM[4]              |IRQWCC
|IRQM[5]              |IRQICC
|===

.Назначение разрядов регистра состояния (status_r)
[cols="16*^", width=99%]
|===
|16    |17   |18   |19   |20   |21   |22   |23    |24    |25     |26     |27     |28     |29     |30     |31
|WRP   |PEF  |Res* |Res* |Res* |Res* |Res* |Res*  |Res*  |IRQRM  |IRQPEM |IRQWLC |IRQLEF |IRQWCC |IRQICС |Res*
|===

.Описание разрядов регистра состояния (status_r)
. WRP - word receiving process, флаг идущего процесса приема слова по SL-каналу
. PEF - parity error flag, присутствует ли ошибка четности в хранящемся в буфере сообщении
. IRQRM - interrupt request of recieved message - прерывание успешно принятого сообщения
. IRQPEM - interrupt request of parity error message, принято слово не прошедшее проверку четности
. IRQWLC - interrupt request of word length check, принято слово не прошедшее проверку длины полученного слова на равенство значению BC регистра config_r
. IRQLE - interrupt request of level error on line, прерывание ошибки уровня напряжения на линии SL-канала
. IRQWCC - interrupt request of wrong configuration changed - прерывание смены конфигурации во время приема сообщения
. IRQICC - interrupt request of incorrect configuration  прерывание попытки смены конфигурации на неверную
. Res* - Зарезервированно

=== Регистр полученных данных
buffered_data_r[31:0]

.Назначение разрядов регистра полученных данных (buffered_data_r)
[cols="1*^", width=99%]
|===
|0 - 31
|Data
|===

Data - данные к отправке.


== Описание работы

Модуль принимает SL-сообщения. Сообщения могут иметь четную длинну от 8 до 32 бит.
Бит четности проверяется автоматически. Частота импульсов принимаемых сообщений может меняться от 500кГц
до 2МГц (при частоте тактового сигнала = 16МГц).

*Запись и чтение регистров*

Управление модулем осуществляется путем записи/чтения регистров.

Для считывания текущего значения одного из регистров блока необходимо сформировать на шине addr соответствующее ему значение,
указанное в таблице, длительностью не меньше такта опорной тактовой частоты.
Значение регистра будет сформировано на шине d_out через такт опорной после фронта сигнала на шине addr.

Для записи значения в один из регистров блока необходимо сформировать:

* на шине addr значение соответствующее регистру
* на шине d_in записываемую информацию,
* на порт wr_en - значение "1".

Также на на шине d_out через такт опорной после фронта сигнала на шине addr будет сформировано значение записанного регистра.
Значение шины d_out будет соответствовать значению последнего опрошенного или записанного регистра до формирования следующего запроса.

.Адреса регистров
[cols="2*^", width=99%]
|===
|Значение шины addr | Выбранный регистр
|1'b0               | регистр данных
|1'b1               | регистр конфигурации и состояния
|===

*Смена конфигурации*

Для изменения конфигурации приемника необходимо перезаписать регистр конфигурации и состояния.
В конфигурационной части может быть установлена длинна слова,
 маскировка причин запроса прерывания или осуществлен сброс модуля к исходным настройкам.
Неверной считается конфигурация с нечетными длинами слова или длинной слова лежащей вне промежутка от 8 до 32 бит.

*Прием сообщений*

Если на вход модуля начинают поступать импульсы, модуль переходит в режим приема сообщения,
выставляется бит WRP = 1.

Модуль переходит в режим ожидания нового сообщения в ситуациях:

* Успешного приема сообщения
* Приема сообщения с ошибкой
* Завершившейся ошибки уровня на линии
* Попытки изменить конфигурацию модуля во время приема сообщения

//При переходе

Успешным приемом сообщения называется прием сообщения с совпадающим со значением поля
BC количеством информационных бит и, если включен контроль четности, верной четностью.

В случае, если успешно принято слово с правильной четностью выставляются биты IRQRM = 1 и WRP = 0.
Если контроль четности отключен и принято слово с неправильной четностью, выставляются биты
IRQPEM = 1, PEF = 1 и  WRP = 0.

В случае приема сообщения с ошибкой выставляются биты:

* Контроль четности включен и принято сообщение с ошибкой четности -- IRQPEM = 1 и  WRP = 0
* Принято сообщение с несовпадающим с конфигурацией количеством бит -- IRQWLC = 1 и  WRP = 0

В случае, если во время приема произошла ошибка уровня, выставляется флаг IRQLEF = 1.
Модуль вернется в режим ожидания сообщения только когда уровень на линиях будет восстановлен.
До этого момента будет флаг WRP = 1, а бит причины прерывания IRQLEF будет невозможно сбросить.

В случае, если во время приема произошла попытка изменить поля PCE и BC регистра конфигурации,
выставляются биты IRQWCC = 1 и WRP = 0. Если новая конфигурация верна, она записывается в регистр.
Если новая конфигурация неверна, выставляется бит IRQICC, поля PCE и BC остаются неизменными.

В регистре данных всегда хранится последнее успешно принятое сообщение.
А в поле PEF регистра состояния - наличие ошибки четности последнего успешно принятого сообщения.

После считывания сообщения необходимо сбросить возникшие биты причин прерываний, и ожидать приема следующего сообщения.

*Прерывания*

Запрос прерывания происходит произошло одно из событий и бит этого события не замаскирован :

* Успешно принято сообщение (IRQRM)
* Принято сообщение с ошибкой четности (IRQPEM)
* Принято сообщение неверной длинны (IRQWLC)
* Произошла ошибка уровня на линии (IRQLE)
* Была предпринята попытка записать некорректные данные в конфигурационный регистр (IRQICC)
* Изменение конфигурации в процессе отправки сообщения (IRQWCC)


Причину возникновения можно посмотреть  в соответствующих полях регистра состояния.
Для сбрасывания прерываний, вам необходимо считать регистр конфигурации и состояния и
записать считанное снова, занулив биты прерываний. Более подробно работа прерываний
рассмотрена в разделе Алгоритм работы.


*Выключение модуля*

Чтобы выключить модуль необходимо выставить поле регистра конфигурации SR = "1".
Если сделать это во время отправки сообщения, прием сообщения прекращается.
Регистры конфигурации и состояния возвращаются в начальное состояние.
Когда приемник выключен, он не реагирует на сигналы на входах SL0 и SL1.

[[rec-irq-Algorythm]]
== Алгоритмы работы
image::image_SlReciever_irq_algorithm.png[title="Алгоритм работы регистра состояния модуля SlReciever", align="center"]
Модуль может находиться в двух режимах: режим приема и режим ожидания. После включения модуля, все биты регистра состояния устанавливаются в 0, модуль
находится в режиме ожидания.

*Смена конфигурации и сброс прерываний в режиме ожидания*

Чтобы сменить конфигурацию, необходимо записать новую конфигурацию в регистр конфигурации и состояния.
При записи регистра конфигурации и состояния в  режиме ожидания происходит проверка
битов причин прерываний: если значения соответствующих записываемых битов прерываний равны 0,
то они сбрасываются.

Если конфигурация некорректна, выставляется IRQICС = 1,
конфигурация не изменяется. Если бит IRQICC не замаскирован
формируется запрос на прерывание.

Если конфигурация корректна она записывается в регистр.
Модуль остается в режиме ожидания.

*Прием сообщения*

Если на одной из линий возникает импульс. модуль переходит в режим приема,
устанавливается поле  регистра состояний WRP = 1.
Если импульс слишком короткий или слишком длинный, возникает ошибка уровня,
выставляется бит IRQLE = 1. Бит выставляется каждый такт, пока уровень на линии не будет восстановлен.
После этого модуль возвращается в режим отправки сообщения, выставляется бит  WRP = 0.

Если импульс является синхроимпульсом модуль выставляет соответствующие принятому сообщению
биты статусного регистра и, если сообщение принято успешно, запоминает сообщение
в регистр данных, выставляется бит WRP = 0.

*Анализ принятого сообщения*

При приеме синхроимпульса (условие END_OF_MSG на рис. 1) сначала проверяется длинна
принятого сообщения, если длинна не совпадает с конфигурацией (значение поля BC + 1 за счет бита четности) выставляется IRQWLC = 1.
Если бит IRQWLC не замаскирован, формируется запрос на прерывание.

Если длинна совпадает с выставленной в конфигурации, проверяется четность полученного сообщения.
Если четность верна, сообщение считается успешно принятым, выставляется IRQRM = 1, содержимое сдвигового регистра с удаленным битом четности
записывается в регистр данных. Если бит IRQRM не замаскирован, формируется запрос на прерывание.

Если четность неверна, выставляется бит IRQPEM = 1. Однако, если контроль четности отключен,
сообщение все равно считается успешно принятым, данные сдвигового регистра с удаленным битом четности переписываются
в регистр данных. Выставляется бит PEF = 1.  Если бит IRQPEM не замаскирован, формируется запрос на прерывание.

*Дублирование битов проверки честности*

Бит причины прерывания IRQPEM и бит четности PEF дублируют функции друг друга.
Тем не менее эта система необходима для разрешения следующего конфликта:
Допустим с приемником с отключенным контролем четности, и за время, прошедшее с последнего
опроса пришло 2 сообщения, одно с верной четностью, а другое с ошибкой.
Тогда флаг PEF - единственный способ определить, верна ли честность сообщения, лежащего в
регистре данных.

*Изменение конфигурации и сброс прерываний во время приема сообщения*

Когда модуль находится в режиме приема сообщения, то без отмены приема возможно только изменение полей маскирования прерываний, и сброс битов причин прерываний.
Если изменить длину сообщения в середине приема сообщения, прием сообщения будет отменен, а остаток сообщения будет воспринят как новое сообщение неправильной длинны.

Если в режиме отправки происходит запись регистра конфигурации и состояния,
сначала проверяются биты прерываний: если значения соответствующих записываемых
битов прерываний равны 0, то они сбрасываются. После этого, проверяется изменяются
ли биты конфигурации (поля PCE, BC). Если они не изменяются, модуль остается
в режиме приема сообщения. Если они изменяются то прием завершается, выставляются
биты WRP = 0 и IRQWCC = 1. Если бит IRQDWСС не замаскирован формируется запрос на прерывание.
 Если конфигурация корректна, она записывается в регистр,
если же нет, выставляется бит IRQICC = 1.
Модуль переходит в режим ожидания сообщения.

*Формирование запроса на прерывание*

Запрос на прерывание формируется на выходе irq, через один такт после возникновения причины прерывания,
если причина этого прерывания не замаскирована в поле IRQM.

image::image_SlReciever_Recieve_algorithm.png[title="Алгоритм работы приема сообщения модуля SlReciever", align="center"]

После включения приемника сдвиговый регистр приема сообщения shift_r заполняется нулями,
Сдвиговых регистры sl_0_tmp и sl_1_tmp - единицами,
счетчик количества бит bit_i устанавливается в 0,
счетчик циклов cycle_i устанавливается в 0,
регистры контроля четности par_0 и par_1 устанавливаются в 0 и 1 соотвественно.

Каждый такт значение с асинхронных входов serial_line_zeroes_a и serial_line_ones_a
помещаются в нулевые разряды сдвиговых регистров sl_0_tmp и sl_1_tmp. Остальные разряды
при этом сдвигаются. Условия bit_started, и bit_ended получаются при сравнении содержимого sl_0_tmp и sl_1_tmp c масками.

.Условия переходов
[cols="2*^", width=99%]
|===
|Обозначение               | Выражение
|bit_started               | (sl0_tmp_r == 12'hF??0) \|\| (sl1_tmp_r == 12'hF??0)
|bit_ended                 | (sl0_tmp_r = =12'h0??F) \|\| (sl1_tmp_r == 12'h0??F)
|===

.Значения костант счетчика cycle_i
[cols="2*^", width=99%]
|===
|Обозначение               | Значение
|const_1                   | 3
|const_2                   | 32
|===
*Состояние BIT_WAIT_FLUSH*

В начале приема машина состояний находится в состоянии BIT_WAIT_FLUSH.
В этом состоянии счетчик циклов приравнивается к константе const1. Если выполняется условие bit_started,
происходит переход в состояние BIT_DETECTED.

*Состояние BIT_DETECTED*

В состоянии BIT_DETECTED работает счетчик циклов cycle_i.
Как только этот счетчик становится равным до 0, производится анализ, какой именно бит принят,
 и в зависимости от
значения первых разрядов сдвиговых регистров sl_0_tmp и sl_1_tmp  определяется,
на какую из линий поступил импульс и происходит переход в состояние обработки определенного бита:
ONE_BIT, ZERO_BIT или STOP_BIT. При этом, если импульс отсутствует, происходит переход в состояние
 LEV_ERR.

*Состояния ONE_BIT и ZERO_BIT*

В состояних ONE_BIT и ZERO_BIT соответствующее значение 0 или 1 загружаются в бит
с номером BC сдвигового регистра shift_r. Сам сдвиговый регистр при этом сдвигается вправо.
В состоянии ONE_BIT инвертируется значение бита четности единиц par_1, в состоянии ZERO_BIT - значение par_0.
В регистр cycle_i помещается значение const2. Счетчик принятых bit_i инкрементируется.

*Состояние STOP_BIT*

В состоянии STOP_BIT происходит анализ полученного сообщения.
Сравнивается количество принятых бит с установленным в конфигурации,
Проверяется четность. Если количество бит и четность верны, или, если верно количество бит,
контроль честности отключен и не верна четность, значение из сдвигового регистра shift_r переписывается
в регистр данных c обнулением бита четности shift_r[BC].

Для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 1. par_1 = 0.
В регистр cycle_i помещается значение const2.

*Особенности контроля честности*

Считая бит честности, количество импульсов на линии единиц с учетом разряда четности должно быть нечетным, а на линии нулей - четным.

Для проверки этого, до приема сообщения в регистры подсчета четности загружаются значения par_0 = 0. par_1 = 1.
При принятии единицы меняет значение на противоположное регистр par_1, а при принятии нуля -- par_0.

Таким образом, после принятия всех бит корректного сообщения (считая бит четности),
регистр par_0 должен поменять свое значение четное количество раз, т.е. сохранить значение par_0 = 0,
а регистр par_1 свое значение нечетное количество раз, т.е. приобрести значение par_1 = 0.

При обработке стоп бита считается, что четность нарушена, если хотя бы один из регистров par_0 и par_1 не равен нулю.

*Состояние WAIT_BIT_END*

После обработки импульса в состояниях ONE_BIT, ZERO_BIT или STOP_BIT, схема переходит в состояние WAIT_BIT_END.
Модуль находится в этом состоянии, пока счетчик cycle_i не достиг нулевого значения, или не выполниться условие bit_ended.

Если выполнилось условие bit_ended, модуль возвращается в состояние BIT_WAIT_FLUSH. Если же счетчик досчитал до нулевого значения,
это значит, что импульс не закончился вовремя, и произошла ошибка уровня на линии - модуль переходит в состояние LEV_ERR.

*Состояние LEV_ERR*

Модуль оказывается в состоянии LEV_ERR в случаях, когда длинна имульса оказалось слишком большой или слишком маленькой,
т.е. произошла ошибка уровня на линии. Когда уровень на обоих линиях восстановлен, модуль переходит в состояние BIT_WAIT_FLUSH.
Для приема следующего сообщения регистры shift_r и bit_i устанавливаются в нулевые значения.
В регистры подсчета четности загружаются значения par_0 = 0 и par_1 = 1.

<<<
// [[rec-state-machine]]
// == Конечный автомат
// image::image_SlReciever_SM.png[title="Конечный автомат модуля SlReciever", align="center"]
// После включения
//
// Каждый такт значение асинхронных входов serial_line_zeroes_a и serial_line_ones_a
// загружается в в первый разряд сдвиговых регистров sl0_tmp_r[15:0] и sl1_tmp_r[15:0],
// регистры сдвигаются.
//
// Когда прием сообщения не начат, модуль находится в состоянии BIT_WAIT_FLUSH,
//  регистр счетчиков бит = 0,
