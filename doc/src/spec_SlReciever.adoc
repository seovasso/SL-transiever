= Спецификация модуля приемника SL-канала : *SlReciever*
//===========
// Compile:
// evgeniy@N7-63:~/Documents/2015VV024/doc$ asciidoctor-pdf -a pdf-style=/home/evgeniy/Documents/RISC-V/fizika-theme.yml -a pdf-fontsdir=/home/evgeniy/Downloads/fonts/Combo/ ./src/2015VV024_datasheet.adoc && mv ./src/2015VV024_datasheet.pdf ./ && evince ./2015VV024_datasheet.pdf
:Authors: Василий Мочалов
:Email:   seovasso@gmail.com
:Date:      13.10.2017
:Revision:  0.3
:toc:       right
:toclevels: 3
:source-highlighter: rouge
:table-caption:     Таблица
:listing-caption:   Код
:chapter-label:     Глава
:toc-title:         Оглавление
:version-label:     Версия
:figure-caption:    Рисунок
:imagesdir:         ./../img/
:sectnums:
:sectnumlevels: 3
:revnumber: 1.1
:revdate:   15.12.2017
:revremark: Рабочая версия


[[rec-main-description]]
== Описание
Данный проект подразумевает реализацию RTL-описания на языке Verilog одноканального приемника SL-канала. Приемник принимает SL-сообщения. Сообщения могут содержать информацию четной разрядности от 8 до 32 разрядов. Разряд четности проверяется автоматически. Приемник способен принимать сообщения с частотой импульсов от 500кГц до 2МГц (при частоте тактового сигнала = 16МГц).

[[rec-top-level-description]]
== Описание верхнего уровня
.Порты цифрового модуля SlReciever
[cols="3*^1,1*^2,1*<3", halign="left", width=99%]
|===
|Название      |Тип   |Разрядность |Значение после сброса |Описание
|_rst_n_       |In    |1           | -                    |Асинхронный общий сигнал сброса
|_clk_         |In    |1           | -                    |Сигнал тактовой частоты
|_addr_        |In    |1           | -                    |Сигнал выбора регистра
|_wr_en_       |In    |1           | -                    |Сигнал разрешения записи
|_SL0_         |In    |1           | -                    |Сигнал нулей SL канала
|_D_in_        |In    |32          | -                    |Шина данных  для записи в регистры
|_SL1_         |in    |1           | -                    |Сигнал единиц SL канала
|_irq_         |Out   |1           |b0                    |Сигнал запроса на прерывание
|_D_out_       |Out   |32          |h0000_0000            |Шина данных для чтения регистров
|===

<<<

[[rec-programm-model]]
== Программная модель
Пользователю для работы доступно два регистра:

* Служебный (*config_status_r*)
* Данных к отправке (*buffered_data_r*)

=== Служебный регистр

Служебный регистр состоит из двух частей - конфигурации и состояния. Части отвечающей за конфигурацию соответствуют младшие 16 разрядов, части состояния старшие.

[[rec_conf_table]]
.Назначение разрядов конфигурационной части служебного регистра (*config_status_r [15:0]*)
[cols="15*^", width=99%]
|===
|Bit        |15-13  |  12 |11 |10 |9  |8   |7       |6 |5 |4 |3 |2 |1 |0
|Name       |-    5+|*IRQM[4:0]*           |*PCE* 6+|*BC[5:0]*        |*SR*
|Mode       |R    5+|R/W                   |R/W   6+|R/W              |R/W
|Initial    |0      |0    |0  |0  |0  |0   |0       |0 |0 |1 |0 |0 |0 |0
|===

.Описание разрядов регистра конфигурационной части служебного регистра (*config_status_r [15:0]*)
. *SR* (soft reset) -- включает (*SR* = 0) и выключает (*SR* = 1) приемник
. *BC* (bit count) -- количество разрядов данных в принимаемом сообщении
. *IRQM* (interrupt request mask) -- маска разрядов причин прерываний.
  Задает, какие именно разряды причин прерываний вызывают запрос на прерывание. Описание разрядов причин прерываний можно посмотреть в <<rec_IRQM_table,таблице назначения разрядов части состояния служебного регистра>>. Соответствие разрядов поля IRQM и разрядов причин прерываний можно посмотреть в соответствующей <<rec_IRQM_table, таблице>>
. *PCE* (parity check enable) -- включение (*PCE* = 1) или выключение(*PCE* = 0) контроля четности

.Назначение разрядов части состояния служебного регистра (*config_status_r [31:16]*)
[cols="11*^", width=99%]
|===
|Bit     |31-30  |29       |28       |27       |26       |25       |24      |23-18 |17    |16
|Name    |-      |-        |*IRQICC* |*IRQLE*  |*IRQWLC* |*IRQPEM* |*IRQRM* |-     |*PEF* |*WRP*
|Mode    |R      |R        |R/W0     |R/W0     |R/W0     |R/W0     |R/W0    |R     |R     |R
|Initial |0      |0        |0        |0        |0        |0        |0       |0     |0     |0
|===

.Описание разрядов части состояния служебного регистра (*config_status_r [31:16]*)
. *WRP* - (word receiving process) -- разряд идущего процесса приема слова по SL-каналу.
. *PEF* - (parity error flag) -- разряд наличия ошибки четности в хранящемся в буфере сообщении.
. *IRQRM* - (interrupt request of recieved message) -- разряд запроса на прерывание успешно принятого сообщения.
. *IRQPEM* - (interrupt request of parity error message) -- разряд запроса на прерывание принятого сообщения не прошедшего проверку четности.
. *IRQWLC* - (interrupt request of word length check) --  разряд запроса на прерывание принятого сообщения неверной длинны.
. *IRQLE* - (interrupt request of level error on line) -- разряд запроса на прерывание ошибки уровня напряжения на линии SL-канала.
. *IRQICC* (interrupt request of incorrect  configuration change ) -- разряд запроса на прерывание попытки установить некорректную конфигурацию.

Разряды *IRQRM*, *IRQPEM*, *IRQWL*, *IRQLE*, *IRQWCC* и *IRQICC* отражают зарегистрированные приемником события. Более подробно события описаны разделе Работа с программной моделью -> <<rec_irq_events, Работа с прерываниями>>.

[[rec_IRQM_table]]
.Соответствие разрядов <<rec_conf_table,*IRQM [4:0]*>> и маскирования разрядов причин прерываний
[cols="2*^", width=99%]
|===
|Разряд поля *IRQM*       |Маскируемый разряд
|*IRQM0*                  |*IRQRM*
|*IRQM1*                  |*IRQPEM*
|*IRQM2*                  |*IRQWLC*
|*IRQM3*                  |*IRQLE*
|*IRQM4*                  |*IRQICC*
|===

=== Регистр полученных данных

.Назначение разрядов регистра полученных данных (*buffered_data_r*)
[cols="2*^", width=99%]
|===
|Bit     |31 - 0
|Name    |*DATA*
|Mode    |R
|Initial |0
|===
.Описание разрядов регистра полученных данных (*buffered_data_r*)
*DATA* - полученные данные

== Работа с программной моделью

=== Запись и чтение регистров
Управление модулем осуществляется путем записи или чтения регистров.

Для считывания текущего значения одного из регистров блока необходимо подать на порт _addr_ адрес регистра, указанный в <<rec_addr_table, таблице>>, длительностью не меньше такта опорной тактовой частоты _clk_. Значение регистра будет сформировано на шине _D_out_ через такт опорной частоты после фронта сигнала на шине _addr_.

Для записи значения в служебный регистр блока необходимо сформировать:

* на порт _addr_ -- адрес выбранного регистра,
* на шине _D_in_ -- записываемую информацию,
* на порт _wr_en_ -- значение 1.

Запись в регистр полученных (*buffered_data_r*) данных игнорируется.

Также на на шине d_out через такт опорной частоты _clk_ после фронта сигнала на шине _addr_ будет сформировано значение записанного регистра. Значение шины d_out будет соответствовать значению последнего опрошенного или записанного регистра до формирования следующего запроса.

image::image_SlReciever_read_write_waveform.png[title="Временная диаграмма чтения и записи регистров модуля SlReciever", align="center"]

[[rec_addr_table]]
.Адреса регистров
[cols="2*^", width=99%]
|===
|Значение сигнала _addr_  | Выбранный регистр
|b0                       | регистр данных (*buffered_data_r*)
|b1                       | служебный регистр (*config_status_r*)
|===



=== Прием сообщений

Для приема сообщений с включенным контролем четности необходимо:

. Записать в регистр *config_r* необходимые настройки длины слова и контроля четности (см. раздел "<<rec_config_change, Смена конфигурации>>")
. Дождавшись запроса на прерывания вызванного успешным приемом сообщения, или, работая по таймеру и периодически опрашивая регистр состояния, убедится, что сообщение было принято  (*IRQRM* == 1).
. Считать принятое сообщение из регистра полученных данных (*buffered_data_r*).
. Сбросить поле причины прерывания *IRQRM*. Возможна работа без сбрасывания поля *IRQRM*, но тогда вы не сможете отличить заново принятое сообщение от принятого в прошлый раз.
. Ожидать следующее сообщение.

Для приема сообщений с отключенным контролем четности необходимо:

. Записать в регистр *config_r* необходимые настройки длины слова и контроля четности (см. раздел "<<rec_config_change, Смена конфигурации>>")
. Дождавшись запроса на прерывания вызванного успешным приемом сообщения или приемом сообщения с ошибкой контроля етности, или, работая по таймеру и периодически опрашивая регистр состояния, убедится, что сообщение было принято  (*IRQRM* == 1 или *IRQPEM* == 1).
. Считать принятое сообщение из регистра полученных данных (*buffered_data_r*).
. Сбросить поля причин прерывания *IRQRM* *IRQPEM*. Возможна работа без сбрасывания этих полей, но тогда вы не сможете отличить заново принятое сообщение от принятого в прошлый раз.
. Ожидать следующее сообщение.

Если вы работаете с отключенным контролем четности периодически опрашивая регистр состояния по таймеру, может возникнуть следующая ситуация - между двумя опросами может прийти два сообщения, одно с ошибкой четности другое нет. В этом случае оба поля  *IRQRM* и *IRQPEM* будут равны единице. В этом случае, чтобы узнать, присутствует ли ошибка четности в принятом сообщении следует воспользоваться полем *PEF*

В случае когда поле BC служебного регистра не равно 32, принятым сообщением являются младшие разряды регистра данных (*buffered_data_r [BC-1:0]*).

Успешным приемом сообщения называется прием сообщения с совпадающим со значением поля
*BC* количеством информационных разрядов и, если включен контроль четности (*PCE* = 1), верной четностью.

В случае, если успешно принято сообщение с правильной четностью выставляются разряды *IRQRM* = 1 и *WRP* = 0. Если контроль четности отключен и принято сообщение с неправильной четностью, выставляются разряды *IRQPEM* = 1, *PEF* = 1 и  *WRP* = 0.

=== Прием сообщений с ошибкой

В случае приема сообщения с ошибкой выставляются следующие разряды:

* Если контроль четности включен и принято сообщение с ошибкой четности -- *IRQPEM* = 1
* Принято сообщение с несовпадающим с конфигурацией количеством разрядов -- *IRQWLC* = 1

Регистр данных при этом не обновляется и продолжает хранить последнее успешно принятое сообщение.

В случае, если во время приема произошла ошибка уровня, выставляется флаг *IRQLEF* = 1.
Модуль вернется в режим ожидания сообщения только когда уровень на линиях будет восстановлен.
До этого момента попытка сброса  разряда причины прерывания *IRQLEF* будет игнорирована.

[[rec_config_change]]
=== Смена конфигурации

В конфигурационной части служебного регистра могут быть установлены контроль четности, длина слова, маскировка причин запроса прерывания или осуществлен сброс модуля к исходным настройкам.

Для изменения конфигурации приемник необходимо записать новые параметры в служебный регистр. Если изменение конфигурации происходит во время приема сообщения, то прием не прерывается, при поступлении синхроимпульса корректность принятого.

В случае, если во время приема произошла попытка изменить поля *PCE* и *BC* и новая
 конфигурация неверна, выставляется разряды *IRQICC*, поля *PCE* и *BC* остаются неизменными.

Некорректной считается конфигурация с нечетными длинами слова или длиной слова лежащей вне промежутка от 8 до 32 разрядов. При попытке записать подобную конфигурацию будет выставлен разряд *IRQICC* = 1, а поля *BC* и *PCE* останутся неизменными.

=== Работа с прерываниями

Запрос прерывания происходит, когда произошло одно из событий и разряд причины прерываний соответствующий этому событию не замаскирован. Узнать какое именно событие вызвало запрос на прерывание можно в <<rec_status_part_table,полях причин прерываний>> служебного регистра.

[[trans_irq_events]]
.События соответствующие разрядам причин прерываний
* *IRQRM* -- Было принято полностью корректное сообщение
* *IRQPEM* -- Было принято сообщение с верной длинной и ошибкой четности
* *IRQWLC* -- Было принято сообщение не прошедшее проверку длины полученного слова.
* *IRQLE* -- Во время приема сообщения произошла ошибка уровня на линии (равенство полю *BC*)
* *IRQICC* -- Была предпринята попытка записать некорректную конфигурацию в конфигурационный регистр

//не прошедшего проверку длины полученного слова.
//на равенство значению BC регистра config_r

Для сброса прерывания необходимо записать 0 в разряды причин прерываний, которые необходимо сбросить.

Более подробно работа прерываний рассмотрена в разделе <<rec-work-algorythm, Алгоритм работы>>.


=== Выключение модуля

Чтобы выключить модуль необходимо записать 1 в разряд *SR* служебного регистра.

Если сделать это во время отправки сообщения, прием прекращается. Служебный регистр возвращается в начальное состояние, регистр данных сбрасывается.


[[rec-work-principle]]
== Принцип работы
На каждом такте значение со входов записывается в сдвиговые регистры линий _SL0_ или _SL1_.

Прием сообщения обеспечивается двумя состояниями: ожидания импульса и приема импульса. Переход между состояниями происходит когда содержимое сдвиговых регистров линий соотвествует маске, таким образом устраняется дребезг сигнала.

В состоянии обработки импульса используется счетчик количества циклов. По нему проверяется длинна импульса - если импульс слишком короткий или слишком длинный, выставляется поле ошибки уровня, а следующий импульс воспринимается как импульс нового сообщения.

Импульс обрабатывается через определенное количество тактов с момента зафиксированного начала импульса. Если импульс является импульсом разряда, то разряд добавляется в сдвиговый регистр сообщения и регистр сдвигается, новый разряд учитывается в проверке четности. Если импульс является синхроимпульсом, то содержимое сдвигового регистра сообщения и счетчика количества разрядов проверяются на соответствие подсчитанный четности и сконфигурированному количеству разрядов. Если проверка прошла успешно, содержимое сдвигового регистра, кроме разряда четности переписывается в регистр данных.

[[rec-work-Algorythm]]
== Алгоритм работы

[cols="3*^1,1*^2,1*<3", halign="left", width=99%]
|===
|Название           |Тип     |Разрядность  |Значение после сброса  |Описание
|_new_conf_is_corr_ |сигнал  |1            |b0 |Сигнал корректности разрядов шины _D_in_ соответствующих полю BC имеют корректное значение
|_level_error_      |сигнал  |1            |b0 |Сигнал присутствия ошибки уровня на линии (импульс слишком короткий или слишком длинный)
|*shift_r*          |регистр |1            |b0 |Сдвиговый регистр с отправляемым сообщением
|*par0*             |регистр |1            |b0 |Регистр подсчета четности на линии нулей
|*par1*             |регистр |1            |b1 |Регистр подсчета четности на линии единиц
|*cycle_counter_r*  |регистр |5            |b0_0000 |Регистр счетчика циклов
|*bit_counter_r*    |регистр |7            |b000_0000 |Регистр счетчика количества импульсов
|*sl0_temp_r*       |регистр |12           |hFFF |Регистр счетчика количества импульсов
|*sl1_temp_r*       |регистр |12           |hFFF |Регистр счетчика количества импульсов
|===

image::image_SlReciever_Recieve_algorithm.png[title="Алгоритм работы приема сообщения модуля SlReciever", align="center"]

Модуль может находиться в двух режимах: режим приема бита и режим ожидания бита. После включения модуля, все разряды части состояния служебного регистра устанавливаются в 0, модуль находится в режиме ожидания бита.

=== Смена конфигурации и сброс прерываний

При записи служебного регистра в  режиме ожидания происходит проверка разрядов прерываний:

. Если значения разрядов шины _D_in_ соответствующие разрядам полей причин прерываний служебного регистра, равны 0, то они записываются в служебный регистр.
. Обновляется поле *IRQM* служебного регистра
. Если значение разрядов шины _D_in_ соответствующие полю *BC* корректно, поля *BC* и *PCE* обновляются. Если значение некорректно, выставляется *IRQICС* = 1, поля *BC* и *PCE* не изменяются.

Корректным значением поля BC называется четное число в интервале от 6'd8 до 6'd32.

=== Прием сообщения

Каждый при принятии импульса на одной из линий, значение соответствующее биту записывается в сдвиговый регистр *shift_r*, и инвертируется соответствующий регистр подсчета четности (*par0*, если зарегистрирован импульс на линии нулей и *par1*, если на линии единиц), счетчик количества разрядов *bit_counter_r*  увеличивается на единицу.

При принятии импульса на обоих линиях (синхроимпульса), сравнивается значение *bit_counter_r* и поля *BC*. Если они неравны выставляется поле *IRQWLC* = 1. Если они равны, проверяется значение регистров *par0* и *par1*:

* Если *par0* и *par1* равны нулю выставляется поле *IRQRM* = 1, содержимое регистра *shift_r*, кроме разряда *shift_r[BC]* переписывается в регистр *buffered_data_r*.
* Если любой из регистров  *par0* или *par1* не равен нулю выставляется поле *IRQPEM* = 1. Если отключен контроль четности (PCE = 0), содержимое регистра *shift_r*, кроме разряда *shift_r[BC]* переписывается в регистр *buffered_data_r*, устанавливается поле *PEF* = 1.

При принятии синхроимпульса или возникновения ошибки уровня на линии регистры *par0*, *par1*, *shift_r* и *bit_counter_r* устанавливаются в начальные значения.

=== Устранение дребезга

Для устранения дребезга используются два сдвиговых регистра - *sl0_tmp_r* и *sl1_tmp_r*. Переход из состояния ожидания бита в состояние обработки бита и обратно производится путем сравнения содержимого этих регистров с масками. Условия переходов приведены в таблице.

.Условия переходов из состояния ожидания импульса в состояние обработки импульса и обратно
[cols="2*^", width=99%]
|===
|Обозначение                 | Выражение
|_bit_started_               | (sl0_tmp_r == 12'hF??0) \|\| (sl1_tmp_r == 12'hF??0)
|_bit_ended_                 | (sl0_tmp_r = =12'h???F) \&\& (sl1_tmp_r == 12'h???F)
|===


=== Ошибка уровня

Для определения ошибки уровня используется счетчик *cycle_counter_r*. Когда модуль находится в режиме обработки бита счетчик переключается от значения CYCLE_MAX до 0.

Обработка бита производится, когда счетчик *cycle_counter_r* равен CYCLE_MAX - CYCLE_MIN. На какой именно линии импульс определяется по разрядам *sl0_tmp_r [POS]* и *sl1_tmp_r [POS]*.

Если сигнал _bit_ended_ устанавливается в единицу, когда счетчик больше числа CYCLE_MAX - CYCLE_MIN, импульс считается помехой, и устанавливается бит *IRQLE* = 1. Регистры *par0*, *par1*, *shift_r* и *bit_counter_r* устанавливаются в начальные значения. Модуль переходит в режим ожидания бита.

Если на сигнал _bit_ended_ не установился в единицу, до того момента, когда счетчик досчитал до нуля, считается что произошел обрыв линии, и устанавливается поле *IRQLE* = 1. Модуль ожидает конца импульса, каждый такт обновляя поле *IRQLE* = 1. Когда сигнал _bit_ended_ устанавливается в единицу, регистры *par0*, *par1*, *shift_r* и *bit_counter_r* устанавливаются в начальные значения, модуль переходит в режим ожидания бита.

.Значения констант счетчика cycle_counter_r
[cols="2*^", width=99%]
|===
|Обозначение               | Значение
|CYCLE_MAX                 | 32
|CYCLE_MIN                 | 8
|POS                       | 0
|===

=== Формирование запроса на прерывание

Запрос на прерывание формируется на выходе _irq_, через один такт после возникновения причины прерывания, если причина этого прерывания не замаскирована в поле <<rec_IRQM_table, *IRQM [4:0]*>>.


<<<
// [[rec-state-machine]]
// == Конечный автомат
// image::image_SlReciever_SM.png[title="Конечный автомат модуля SlReciever", align="center"]
// После включения
//
// Каждый такт значение асинхронных входов serial_line_zeroes_a и serial_line_ones_a
// загружается в в первый разряд сдвиговых регистров sl0_tmp_r[15:0] и sl1_tmp_r[15:0],
// регистры сдвигаются.
//
// Когда прием сообщения не начат, модуль находится в состоянии BIT_WAIT_FLUSH,
//  регистр счетчиков бит = 0,
